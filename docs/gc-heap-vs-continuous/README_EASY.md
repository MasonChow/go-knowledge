# GC 追踪压力：一眼看穿你的 Go 程序为什么慢

---

## 1. 连续 vs 分散，GC 到底在忙什么？

想象你有两种收纳方式：

- **连在一起的抽屉柜**（连续内存，如`[]Type`）：所有东西都整齐排在一排。
- **分散在各个房间的盒子**（分散堆对象，如`[]*Type`）：每个东西都单独放在不同房间。

清理时，第一种你只要扫一遍抽屉就行，第二种你得挨个房间找。

---

## 2. GC 怎么“找东西”？效率差距有多大？

- **连续内存**：GC 只需跟着一条线走，效率高。
- **分散堆对象**：GC 要一条条线去找每个盒子，数量多，效率低。

### 图示：

- 连续：Root → [数据块]
- 分散：Root → [对象 1]、[对象 2]、[对象 3]...

---

## 3. 性能对比：一张表看懂谁更快

| 方式       | GC 要找的对象数 | GC 耗时 | CPU 占用 | 适用场景      |
| ---------- | --------------- | ------- | -------- | ------------- |
| 连续内存   | 1               | 低      | 低       | 只读/遍历多   |
| 分散堆对象 | 很多            | 高      | 高       | 频繁修改/共享 |

---

## 4. 生活化总结：你的内存像书架还是迷宫？

- 连续内存：像一排书架，清点快。
- 分散堆对象：像书分散在不同房间，清点慢。

---

## 5. 设计建议：什么场景该用哪种？

- 数据量大、只读、遍历多：优先用连续内存（如`[]Type`）。
- 需要频繁修改/共享：可以用指针切片（如`[]*Type`），但要关注 GC 性能。

---

## 6. 结论：选对内存布局，GC 轻松程序快

- 连续内存让 GC 轻松，程序快。
- 堆对象多时，GC 压力大，程序慢。
- 设计数据结构时，优先考虑连续存储，除非必须用指针。
