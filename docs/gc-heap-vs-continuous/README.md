# 为什么大量堆对象，GC 追踪比数据连续压力大？

---

## 一、主题简介

在 Go 语言开发中，数据可以连续存储（如数组、切片），也可以分散在堆上（如指针数组，每个元素都是堆对象）。这两种方式对 GC（垃圾回收器）的压力差异很大。

---

## 二、内存布局对比

### 1. 连续内存（如 `[]Type`）

```
+-------------------------------+
|   数据1 | 数据2 | 数据3 | ... |
+-------------------------------+
（内存中一块区域，数据紧挨着）
```

### 2. 分散堆对象（如 `[]*Type`）

```
+-----+-----+-----+
| 指针| 指针| 指针|
+--|--+--|--+--|--+
   |     |     |
   v     v     v
[堆1] [堆2] [堆3] ...
（每个指针指向内存中不同位置）
```

---

## 三、GC 追踪原理

- **连续内存**：GC 只需追踪一块大内存。
- **分散堆对象**：GC 需要追踪每个指针指向的对象，数量成百上千。

### 图示：GC 追踪路径

```
连续：
Root
 |
 +--[数据块]

分散：
Root
 |---> [对象1]
 |---> [对象2]
 |---> [对象3]
 ...
```

---

## 四、性能影响

| 方式       | GC 追踪对象数 | GC 时间 | CPU 占用 | 适用场景        |
| ---------- | ------------- | ------- | -------- | --------------- |
| 连续内存   | 1             | 低      | 低       | 只读/遍历多     |
| 分散堆对象 | N（很大）     | 高      | 高       | 需频繁修改/共享 |

> **结论**：对象越分散，GC 需要检查的对象越多，回收更慢，CPU 占用更高。

---

## 五、生活化比喻

- **连续内存**：像一排整齐的书架，清点书本很快。
- **分散堆对象**：像把书分散在不同房间，清点每本书要跑很多趟。

---

## 六、业务建议

- 数据量大、只读、遍历多：优先用连续内存（如 `[]Type`）。
- 需要频繁修改/共享大对象：可用指针切片（如 `[]*Type`），但要关注 GC 性能。

---

## 七、结论

- 连续内存让 GC 轻松，性能更好。
- 堆对象多时，GC 负担重，程序可能变慢。
- 设计数据结构时，优先考虑连续存储，除非必须用指针。

---

## 八、Go 实测基准

> Apple M2, go test -bench=. -benchmem

| 方式       | 平均耗时（ms/op） | GC 次数（numGC） | GC 暂停（ms） | 内存分配（MB） | 分配次数（allocs/op） | 说明                          |
| ---------- | ----------------- | ---------------- | ------------- | -------------- | --------------------- | ----------------------------- |
| 连续内存   | 3.9               | 2.0              | 0.038         | 320            | 1                     | 一次分配到位，GC 负担极低     |
| 分散堆对象 | 146               | 4.0              | 0.140         | 400            | 10,000,001            | 每个元素单独分配，GC 负担极高 |

- **连续内存**：GC 次数少，暂停时间极短，分配次数极低。
- **分散堆对象**：GC 次数多，暂停时间更长，分配次数极高。

> 结论：实际测试印证了理论分析，分散堆对象对 GC 压力远大于连续内存。
